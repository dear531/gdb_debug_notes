GDB设置命令行参数:
 一般有2种方法。
    1 直接跟在run后面
     (gdb) r arg1 arg2 ...
    2 用命令
     (gdb) set args arg1 arg2 ...
上述两步操作必须要在程序未运行起来之前，或是在程序运行起来之时进行赋值，如若会出现不生效的情况。

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

命令行参数的传入：
两种方法：
1。run ＋ 命令行
run -p 123
Starting program: /root/test/a.out -p 123
opt:123

Program exited normally.

2。set args ＋ 命令行
(gdb) set args -p 456
(gdb) run 
Starting program: /root/test/a.out -p 456
opt:456

Program exited normally.

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

查看程序的状态：
info grogram
(gdb) info program 
        Using the running image of child process 22717.
Program stopped at 0x4004e7.
It stopped at a breakpoint that has since been deleted.
(gdb) 

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
观察点设置：

(gdb) start 
Temporary breakpoint 1 at 0x4004e7: file pool4watch.c, line 7.
Starting program: /root/test/a.out 

Temporary breakpoint 1, main (argc=1, argv=0x7fffffffea58) at pool4watch.c:7
7               for (i = 0; i < 5; i++) 
(gdb) info program 
        Using the running image of child process 29284.
Program stopped at 0x4004e7.
It stopped at a breakpoint that has since been deleted.
(gdb) list
2
3       int main(int argc, char *argv[])
4       {
5               int i;
6               int j;
7               for (i = 0; i < 5; i++)
8               {
9                       fprintf(stdout, "i :%d", i);
10                      j++;
11                      fprintf(stdout, "j :%d\n", j);
(gdb) watch 10
Cannot watch constant value 10.
(gdb) break 10
Breakpoint 2 at 0x400509: file pool4watch.c, line 10.
(gdb) run 
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /root/test/a.out 

Breakpoint 2, main (argc=1, argv=0x7fffffffea58) at pool4watch.c:10
10                      j++;
(gdb) watch j
Hardware watchpoint 3: j
(gdb) c
Continuing.
i :0j :1

Breakpoint 2, main (argc=1, argv=0x7fffffffea58) at pool4watch.c:10
10                      j++;
(gdb) print j
$1 = 1
(gdb) c
Continuing.
i :1j :2

Breakpoint 2, main (argc=1, argv=0x7fffffffea58) at pool4watch.c:10
10                      j++;
(gdb) print j
$2 = 2
(gdb) 

＝＝＝＝＝＝＝＝＝＝＝
使用watch时步骤如下：

1. 使用break在要观察的变量所在处设置断电；

2. 使用run执行，直到断点；

3. 使用watch设置观察点；

4. 使用continue观察设置的观察点是否有变化。

注意，以上步骤前三步为一次性的设置，而第四步为成寻运行起来之后，在程序停在断点的时候让程序继续运行的设置。

＝＝＝＝＝＝＝＝＝＝＝
gdb 在断点打印,分别为设置断点号方法和不设置断点号方法：

1.设置断点号码的方法：

(gdb) break 9
Breakpoint 36 at 0x400510: file pool4watch.c, line 9.
(gdb) commands 36
Type commands for when breakpoint 36 is hit, one per line.
End with a line saying just "end".
>printf "i:%d\n",i
>continue
>end
(gdb) run
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Breakpoint 36, main (argc=1, argv=0x7fffffffe9c8) at pool4watch.c:9
9                       j++;
i:0
i :0,j :1

Breakpoint 36, main (argc=1, argv=0x7fffffffe9c8) at pool4watch.c:9
9                       j++;
i:1
i :1,j :2

Breakpoint 36, main (argc=1, argv=0x7fffffffe9c8) at pool4watch.c:9
9                       j++;
i:2
i :2,j :3

Breakpoint 36, main (argc=1, argv=0x7fffffffe9c8) at pool4watch.c:9
9                       j++;
i:3
i :3,j :4

Breakpoint 36, main (argc=1, argv=0x7fffffffe9c8) at pool4watch.c:9
9                       j++;
i:4
i :4,j :5

Program exited normally.
(gdb) 

2.不设置断点号的方法，新设置的commadn命令，会自动查找最近设置的断点号，并附加其上：
(gdb) break 9
Breakpoint 1 at 0x400510: file pool4watch.c, line 9.
(gdb) commands 
Type commands for when breakpoint 1 is hit, one per line.
End with a line saying just "end".
>printf "i :%d\n",i
>continue
>end
(gdb) run 
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Breakpoint 1, main (argc=1, argv=0x7fffffffe9c8) at pool4watch.c:9
9                       j++;
i :0
i :0,j :1

Breakpoint 1, main (argc=1, argv=0x7fffffffe9c8) at pool4watch.c:9
9                       j++;
i :1
i :1,j :2

Breakpoint 1, main (argc=1, argv=0x7fffffffe9c8) at pool4watch.c:9
9                       j++;
i :2
i :2,j :3

Breakpoint 1, main (argc=1, argv=0x7fffffffe9c8) at pool4watch.c:9
9                       j++;
i :3
i :3,j :4

Breakpoint 1, main (argc=1, argv=0x7fffffffe9c8) at pool4watch.c:9
9                       j++;
i :4
i :4,j :5

Program exited normally.
(gdb) 
(gdb) info breakpoints 
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000400510 in main at pool4watch.c:9
        breakpoint already hit 5 times
        printf "i :%d\n",i
        continue
(gdb) 

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

查看观察点方法：
watch <expr>
    为表达式（变量）expr设置一个观察点。一表达式值有变化时，马上停住程序。 

rwatch(read) <expr>
    当表达式（变量）expr被读时，停住程序。 

awatch(access:read/write) <expr>
    当表达式（变量）的值被读或被写时，停住程序。 

info watchpoints
    列出当前所设置了的所有观察点。 
(gdb) start 
Temporary breakpoint 1 at 0x4004e7: file pool4watch.c, line 5.
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Temporary breakpoint 1, main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:5
5               int i, j = 0;
(gdb) watch i
Hardware watchpoint 2: i
(gdb) awatch i
Hardware access (read/write) watchpoint 3: i
(gdb) rwatch i
Hardware read watchpoint 4: i
(gdb) info watchpoints 
Num     Type           Disp Enb Address            What
2       hw watchpoint  keep y                      i
3       acc watchpoint keep y                      i
4       read watchpoint keep y                      i
(gdb) c
Continuing.
Hardware access (read/write) watchpoint 3: i

Value = 0
Hardware read watchpoint 4: i

Value = 0
0x00000000004004f5 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:6
6               for (i = 0; i < 5; i++)
(gdb) c
Continuing.
Hardware access (read/write) watchpoint 3: i

Value = 0
Hardware read watchpoint 4: i

Value = 0
0x0000000000400535 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:6
6               for (i = 0; i < 5; i++)
(gdb) c
Continuing.
Hardware access (read/write) watchpoint 3: i

Value = 0
Hardware read watchpoint 4: i

Value = 0
0x0000000000400501 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:8
8                       fprintf(stdout, "i :%d,", i);
(gdb) c
Continuing.
i :0,j :1
Hardware watchpoint 2: i

Old value = 0
New value = 1
Hardware access (read/write) watchpoint 3: i

Old value = 0
New value = 1
0x0000000000400531 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:6
6               for (i = 0; i < 5; i++)
(gdb) c
Continuing.
Hardware access (read/write) watchpoint 3: i

Value = 1
Hardware read watchpoint 4: i

Value = 1
0x0000000000400535 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:6
6               for (i = 0; i < 5; i++)
(gdb) c
Continuing.
Hardware access (read/write) watchpoint 3: i

Value = 1
Hardware read watchpoint 4: i

Value = 1
0x0000000000400501 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:8
8                       fprintf(stdout, "i :%d,", i);
(gdb) c
Continuing.
i :1,j :2
Hardware watchpoint 2: i

Old value = 1
New value = 2
Hardware access (read/write) watchpoint 3: i

Old value = 1
New value = 2
0x0000000000400531 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:6
6               for (i = 0; i < 5; i++)
(gdb) c
Continuing.
Hardware access (read/write) watchpoint 3: i

Value = 2
Hardware read watchpoint 4: i

Value = 2
0x0000000000400535 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:6
6               for (i = 0; i < 5; i++)
(gdb) c
Continuing.
Hardware access (read/write) watchpoint 3: i

Value = 2
Hardware read watchpoint 4: i

Value = 2
0x0000000000400501 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:8
8                       fprintf(stdout, "i :%d,", i);
(gdb) c
Continuing.
i :2,j :3
Hardware watchpoint 2: i

Old value = 2
New value = 3
Hardware access (read/write) watchpoint 3: i

Old value = 2
New value = 3
0x0000000000400531 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:6
6               for (i = 0; i < 5; i++)
(gdb) c
Continuing.
Hardware access (read/write) watchpoint 3: i

Value = 3
Hardware read watchpoint 4: i

Value = 3
0x0000000000400535 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:6
6               for (i = 0; i < 5; i++)
(gdb) c
Continuing.
Hardware access (read/write) watchpoint 3: i

Value = 3
Hardware read watchpoint 4: i

Value = 3
0x0000000000400501 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:8
8                       fprintf(stdout, "i :%d,", i);
(gdb) c
Continuing.
i :3,j :4
Hardware watchpoint 2: i

Old value = 3
New value = 4
Hardware access (read/write) watchpoint 3: i

Old value = 3
New value = 4
0x0000000000400531 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:6
6               for (i = 0; i < 5; i++)
(gdb) c
Continuing.
Hardware access (read/write) watchpoint 3: i

Value = 4
Hardware read watchpoint 4: i

Value = 4
0x0000000000400535 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:6
6               for (i = 0; i < 5; i++)
(gdb) c
Continuing.
Hardware access (read/write) watchpoint 3: i

Value = 4
Hardware read watchpoint 4: i

Value = 4
0x0000000000400501 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:8
8                       fprintf(stdout, "i :%d,", i);
(gdb) c
Continuing.
i :4,j :5
Hardware watchpoint 2: i

Old value = 4
New value = 5
Hardware access (read/write) watchpoint 3: i

Old value = 4
New value = 5
0x0000000000400531 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:6
6               for (i = 0; i < 5; i++)
(gdb) c
Continuing.
Hardware access (read/write) watchpoint 3: i

Value = 5
Hardware read watchpoint 4: i

Value = 5
0x0000000000400535 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:6
6               for (i = 0; i < 5; i++)
(gdb) c
Continuing.

Watchpoint 2 deleted because the program has left the block in
which its expression is valid.

Watchpoint 3 deleted because the program has left the block in
which its expression is valid.

Watchpoint 4 deleted because the program has left the block in
which its expression is valid.
0x000000347861d994 in __libc_start_main () from /lib64/libc.so.6
(gdb) c
Continuing.

Program exited normally.
(gdb) info watchpoints 
No breakpoints or watchpoints.
(gdb) 

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

watch是有作用域的，只有在有效的作用域内，才能可以设置为该变量的观察点。
  1 #include <stdio.h>
  2 
  3 int watch_variable_another(void)
  4 {
  5         int k;
  6         for (k = 0; k < 5; k++)
  7         {
  8                 fprintf(stdout, "k:%d\n", k);
  9         }
 10         return 0;
 11 }
 12 int main(int argc, char *argv[])
 13 {
 14         int i, j = 0;
 15         for (i = 0; i < 5; i++)
 16         {
 17                 fprintf(stdout, "i :%d,", i);
 18                 j++;
 19                 fprintf(stdout, "j :%d\n", j);
 20         }
 21         watch_variable_another();
 22 
 23         return 0;
 24 }

以下是上述代码在调试的结果，只有在进入子函数当中，变量"k"的观察点才生效。

(gdb) start 
Temporary breakpoint 1 at 0x400522: file pool4watch.c, line 14.
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Temporary breakpoint 1, main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:14
14              int i, j = 0;
(gdb) watch k
No symbol "k" in current context.
(gdb) n
15              for (i = 0; i < 5; i++)
(gdb) n
17                      fprintf(stdout, "i :%d,", i);
(gdb) n
18                      j++;
(gdb) n
19                      fprintf(stdout, "j :%d\n", j);
(gdb) n
i :0,j :1
15              for (i = 0; i < 5; i++)
(gdb) n
17                      fprintf(stdout, "i :%d,", i);
(gdb) n
18                      j++;
(gdb) list
13      {
14              int i, j = 0;
15              for (i = 0; i < 5; i++)
16              {
17                      fprintf(stdout, "i :%d,", i);
18                      j++;
19                      fprintf(stdout, "j :%d\n", j);
20              }
21              watch_variable_another();
22
(gdb) break 20
Breakpoint 2 at 0x400572: file pool4watch.c, line 20.
(gdb) c
Continuing.
i :1,j :2
i :2,j :3
i :3,j :4
i :4,j :5

Breakpoint 2, main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:21
21              watch_variable_another();
(gdb) watch k
No symbol "k" in current context.
(gdb) s
watch_variable_another () at pool4watch.c:6
6               for (k = 0; k < 5; k++)
(gdb) watch k
Hardware watchpoint 3: k
(gdb) 

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

停止条件维护clean和delete删除维护点的区别：
clean删除行号，delete断点号。

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
前面在说到设置断点时，我们提到过可以设置一个条件，当条件成立时，程序自动停止，这是一个非常强大的功能，这里，我想专门说说这个条件的相关维护命令。一般来说，为断点设置一个条件，我们使用if关键词，后面跟其断点条件。并且，条件设置好后，我们可以用condition命令来修改断点的条件。（只有break和watch命令支持if，catch目前暂不支持if）

condition <bnum> <expression>
    修改断点号为bnum的停止条件为expression。 

condition <bnum>
    清除断点号为bnum的停止条件。 
停止点条件变更：condition

(gdb) break 18
Breakpoint 1 at 0x40054b: file pool4watch.c, line 18.
(gdb) info breakpoints 
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x000000000040054b in main at pool4watch.c:18
(gdb) condition 1 i>2
(gdb) info breakpoints 
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x000000000040054b in main at pool4watch.c:18
        stop only if i>2
(gdb) 

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
还有一个比较特殊的维护命令ignore，你可以指定程序运行时，忽略停止条件几次。

ignore <bnum> <count>
    表示忽略断点号为bnum的停止条件count次。 

忽略断点ignore
Reading symbols from /mnt/data/gdb_debug_notes/source_code/a.out...done.
(gdb) list
5               int k;
6               for (k = 0; k < 5; k++)
7               {
8                       fprintf(stdout, "k:%d\n", k);
9               }
10              return 0;
11      }
12      int main(int argc, char *argv[])
13      {
14              int i, j = 0;
(gdb) list
15              for (i = 0; i < 5; i++)
16              {
17                      fprintf(stdout, "i :%d,", i);
18                      j++;
19                      fprintf(stdout, "j :%d\n", j);
20              }
21              watch_variable_another();
22
23              return 0;
24      }
(gdb) break 18
Breakpoint 1 at 0x40054b: file pool4watch.c, line 18.
(gdb) ignore 1 2
Will ignore next 2 crossings of breakpoint 1.
(gdb) run
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 
i :0,j :1
i :1,j :2

Breakpoint 1, main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:18
18                      j++;
(gdb) c
Continuing.
i :2,j :3

Breakpoint 1, main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:18
18                      j++;
(gdb) c
Continuing.
i :3,j :4

Breakpoint 1, main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:18
18                      j++;
(gdb) c
Continuing.
i :4,j :5
k:0
k:1
k:2
k:3
k:4

Program exited normally.
(gdb) 


＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
为停止点设定运行命令

我们可以使用GDB提供的command命令来设置停止点的运行命令。也就是说，当运行的程序在被停止住时，我们可以让其自动运行一些别的命令，这很有利行自动化调试。对基于GDB的自动化调试是一个强大的支持。

commands [bnum]
... command-list ...
end

为断点号bnum指写一个命令列表。当程序被该断点停住时，gdb会依次运行命令列表中的命令。例如：

break foo if x>0
commands
printf "x is %d\n",x
continue
end

断点设置在函数foo中，断点条件是x>0，如果程序被断住后，也就是，一旦x的值在foo函数中大于0，GDB会自动打印出x的值，并继续运行程序。

如果你要清除断点上的命令序列，那么只要简单的执行一下commands命令，并直接再打个end就行了。 

example:
(gdb) list
5               int k;
6               for (k = 0; k < 5; k++)
7               {
8                       fprintf(stdout, "k:%d\n", k);
9               }
10              return 0;
11      }
12      int main(int argc, char *argv[])
13      {
14              int i, j = 0;
(gdb) list
15              for (i = 0; i < 5; i++)
16              {
17                      fprintf(stdout, "i :%d,", i);
18                      j++;
19                      fprintf(stdout, "j :%d\n", j);
20              }
21              watch_variable_another();
22
23              return 0;
24      }
(gdb) break 18 if i%2==0
Breakpoint 1 at 0x40054b: file pool4watch.c, line 18.
(gdb) commands
Type commands for when breakpoint 1 is hit, one per line.
End with a line saying just "end".
>printf "i*2 = %d\n",i*2
>continue
>end
(gdb) run
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Breakpoint 1, main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:18
18                      j++;
i*2 = 0
i :0,j :1
i :1,j :2

Breakpoint 1, main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:18
18                      j++;
i*2 = 4
i :2,j :3
i :3,j :4

Breakpoint 1, main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:18
18                      j++;
i*2 = 8
i :4,j :5
k:0
k:1
k:2
k:3
k:4

Program exited normally.
(gdb) 

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
step或next命令单步跟踪程序。

continue [ignore-count]
c [ignore-count]
fg [ignore-count]
    恢复程序运行，直到程序结束，或是下一个断点到来。ignore-count表示忽略其后的断点次数。continue，c，fg三个命令都是一样的意思。 

step <count>
    单步跟踪，如果有函数调用，他会进入该函数。进入函数的前提是，此函数被编译有debug信息。很像VC等工具中的step in。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。 

next <count>
    同样单步跟踪，如果有函数调用，他不会进入该函数。很像VC等工具中的step over。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。 

(gdb) list
1       #include <stdio.h>
2
3       int watch_variable_another(void)
4       {
5               int k;
6               for (k = 0; k < 5; k++)
7               {
8                       fprintf(stdout, "k:%d\n", k);
9               }
10              return 0;
(gdb) list
11      }
12      int main(int argc, char *argv[])
13      {
14              int i, j = 0;
15              for (i = 0; i < 5; i++)
16              {
17                      fprintf(stdout, "i :%d,", i);
18                      j++;
19                      fprintf(stdout, "j :%d\n", j);
20              }
(gdb) list
21              watch_variable_another();
22
23              return 0;
24      }
(gdb) list
Line number 25 out of range; pool4watch.c has 24 lines.
(gdb) start 
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Temporary breakpoint 6 at 0x400522: file pool4watch.c, line 14.
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Temporary breakpoint 6, main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:14
14              int i, j = 0;
(gdb) n 3
18                      j++;
(gdb) n 5
i :0,j :1
19                      fprintf(stdout, "j :%d\n", j);
(gdb) s 10
i :1,j :2
i :2,j :3
i :3,j :4
17                      fprintf(stdout, "i :%d,", i);
(gdb) s 1
18                      j++;
(gdb) s
19                      fprintf(stdout, "j :%d\n", j);
(gdb) s 2
i :4,j :5
21              watch_variable_another();
(gdb) s 10
k:0
k:1
k:2
k:3
8                       fprintf(stdout, "k:%d\n", k);
(gdb) s 2
k:4
10              return 0;
(gdb) s
11      }
(gdb) s
main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:23
23              return 0;
(gdb) 

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
set step-mode
set step-mode on
    打开step-mode模式，于是，在进行单步跟踪时，程序不会因为没有debug信息而不停住。这个参数很有利于查看机器码。 

set step-mode off
    关闭step-mode模式。 
如果代码没有调试信息，那么设置step模式开启，也是见很痛苦的事：
第一，c代码汇编为机器码之后要比c行数多的多。
第二，当代码涉及到系统库函数时，也会跟进去，这时候可以用finish结束。这个语句除了结束自定义函数，也可以用来结束库函数。

(gdb) set step-mode on
(gdb) start 
Temporary breakpoint 5 at 0x400517
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Temporary breakpoint 5, 0x0000000000400517 in main ()
(gdb) n
0x000000000040051b in main ()
(gdb) s
0x000000000040051e in main ()
(gdb) s
0x0000000000400522 in main ()
(gdb) s
0x0000000000400529 in main ()
(gdb) s
0x00000000004004d8 in watch_variable_another ()
(gdb) s
0x00000000004004d9 in watch_variable_another ()
(gdb) s
0x00000000004004dc in watch_variable_another ()
(gdb) s
0x00000000004004e0 in watch_variable_another ()
(gdb) s
0x00000000004004e7 in watch_variable_another ()
(gdb) s
0x0000000000400506 in watch_variable_another ()
(gdb) s
0x000000000040050a in watch_variable_another ()
(gdb) s
0x00000000004004e9 in watch_variable_another ()
(gdb) s
0x00000000004004f0 in watch_variable_another ()
(gdb) s
0x00000000004004f3 in watch_variable_another ()
(gdb) s
0x00000000004004f8 in watch_variable_another ()
(gdb) n
0x00000000004004fd in watch_variable_another ()
(gdb) finish
Run till exit from #0  0x00000000004004fd in watch_variable_another ()
k:0
k:1
k:2
k:3
k:4
0x000000000040052e in main ()
(gdb) s
0x0000000000400535 in main ()
(gdb) s
0x0000000000400571 in main ()
(gdb) s
0x0000000000400575 in main ()
(gdb) s
0x0000000000400537 in main ()
(gdb) s
0x000000000040053e in main ()
(gdb) print i
No symbol table is loaded.  Use the "file" command.
(gdb) s
0x0000000000400541 in main ()
(gdb) s
0x0000000000400546 in main ()
(gdb) s
0x000000000040054b in main ()
(gdb) s
0x000000347864d2d0 in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2d7 in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2dc in fprintf () from /lib64/libc.so.6
(gdb) finish
Run till exit from #0  0x000000347864d2dc in fprintf () from /lib64/libc.so.6
0x0000000000400550 in main ()
(gdb) s
0x0000000000400554 in main ()
(gdb) s
0x000000000040055b in main ()
(gdb) s
0x000000000040055e in main ()
(gdb) s
0x0000000000400563 in main ()
(gdb) s
0x0000000000400568 in main ()
(gdb) s
0x000000347864d2d0 in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2d7 in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2dc in fprintf () from /lib64/libc.so.6
(gdb) finish
Run till exit from #0  0x000000347864d2dc in fprintf () from /lib64/libc.so.6
i :0,j :1
0x000000000040056d in main ()
(gdb) s
0x0000000000400571 in main ()
(gdb) s
0x0000000000400575 in main ()
(gdb) s
0x0000000000400537 in main ()
(gdb) s
0x000000000040053e in main ()
(gdb) n
0x0000000000400541 in main ()
(gdb) n
0x0000000000400546 in main ()
(gdb) n
0x000000000040054b in main ()
(gdb) n
0x0000000000400550 in main ()
(gdb) n
0x0000000000400554 in main ()
(gdb) finish
"finish" not meaningful in the outermost frame.
(gdb) s
0x000000000040055b in main ()
(gdb) s
0x000000000040055e in main ()
(gdb) s
0x0000000000400563 in main ()
(gdb) s
0x0000000000400568 in main ()
(gdb) s
0x000000347864d2d0 in fprintf () from /lib64/libc.so.6
(gdb) finish
Run till exit from #0  0x000000347864d2d0 in fprintf () from /lib64/libc.so.6
i :1,j :2
0x000000000040056d in main ()
(gdb) s
0x0000000000400571 in main ()
(gdb) s
0x0000000000400575 in main ()
(gdb) s
0x0000000000400537 in main ()
(gdb) s
0x000000000040053e in main ()
(gdb) s
0x0000000000400541 in main ()
(gdb) s
0x0000000000400546 in main ()
(gdb) s
0x000000000040054b in main ()
(gdb) s
0x000000347864d2d0 in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2d7 in fprintf () from /lib64/libc.so.6
(gdb) finish
Run till exit from #0  0x000000347864d2d7 in fprintf () from /lib64/libc.so.6
0x0000000000400550 in main ()
(gdb) s
0x0000000000400554 in main ()
(gdb) s
0x000000000040055b in main ()
(gdb) s
0x000000000040055e in main ()
(gdb) s
0x0000000000400563 in main ()
(gdb) s
0x0000000000400568 in main ()
(gdb) s
0x000000347864d2d0 in fprintf () from /lib64/libc.so.6
(gdb) finish
Run till exit from #0  0x000000347864d2d0 in fprintf () from /lib64/libc.so.6
i :2,j :3
0x000000000040056d in main ()
(gdb) s
0x0000000000400571 in main ()
(gdb) s
0x0000000000400575 in main ()
(gdb) s
0x0000000000400537 in main ()
(gdb) s
0x000000000040053e in main ()
(gdb) s
0x0000000000400541 in main ()
(gdb) s
0x0000000000400546 in main ()
(gdb) s
0x000000000040054b in main ()
(gdb) s
0x000000347864d2d0 in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2d7 in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2dc in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2df in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2e4 in fprintf () from /lib64/libc.so.6
(gdb) finish
Run till exit from #0  0x000000347864d2e4 in fprintf () from /lib64/libc.so.6
0x0000000000400550 in main ()
(gdb) s
0x0000000000400554 in main ()
(gdb) s
0x000000000040055b in main ()
(gdb) s
0x000000000040055e in main ()
(gdb) s
0x0000000000400563 in main ()
(gdb) s
0x0000000000400568 in main ()
(gdb) s
0x000000347864d2d0 in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2d7 in fprintf () from /lib64/libc.so.6
(gdb) finish
Run till exit from #0  0x000000347864d2d7 in fprintf () from /lib64/libc.so.6
i :3,j :4
0x000000000040056d in main ()
(gdb) s
0x0000000000400571 in main ()
(gdb) s
0x0000000000400575 in main ()
(gdb) s
0x0000000000400537 in main ()
(gdb) s
0x000000000040053e in main ()
(gdb) s
0x0000000000400541 in main ()
(gdb) s
0x0000000000400546 in main ()
(gdb) s
0x000000000040054b in main ()
(gdb) s
0x000000347864d2d0 in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2d7 in fprintf () from /lib64/libc.so.6
(gdb) finish
Run till exit from #0  0x000000347864d2d7 in fprintf () from /lib64/libc.so.6
0x0000000000400550 in main ()
(gdb) s
0x0000000000400554 in main ()
(gdb) s
0x000000000040055b in main ()
(gdb) s
0x000000000040055e in main ()
(gdb) s
0x0000000000400563 in main ()
(gdb) s
0x0000000000400568 in main ()
(gdb) s
0x000000347864d2d0 in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2d7 in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2dc in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2df in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2e4 in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2ec in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2f3 in fprintf () from /lib64/libc.so.6
(gdb) finish
Run till exit from #0  0x000000347864d2f3 in fprintf () from /lib64/libc.so.6
i :4,j :5
0x000000000040056d in main ()
(gdb) s
0x0000000000400571 in main ()
(gdb) s
0x0000000000400575 in main ()
(gdb) s
0x0000000000400577 in main ()
(gdb) s
0x000000000040057c in main ()
(gdb) s
0x000000000040057d in main ()
(gdb) s
0x000000347861d994 in __libc_start_main () from /lib64/libc.so.6
(gdb) s
0x000000347861d996 in __libc_start_main () from /lib64/libc.so.6
(gdb) s
0x00000034786332c0 in exit () from /lib64/libc.so.6
(gdb) s
0x00000034786332c2 in exit () from /lib64/libc.so.6
(gdb) finish
Run till exit from #0  0x00000034786332c2 in exit () from /lib64/libc.so.6

Program exited normally.
(gdb) s
The program is not being run.

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
结束子函数执行：finish

finish
    运行程序，直到当前函数完成返回。并打印函数返回时的堆栈地址和返回值及参数值等信息。 
(gdb) list
5               int k;
6               for (k = 0; k < 5; k++)
7               {
8                       fprintf(stdout, "k:%d\n", k);
9               }
10              return 0;
11      }
12      int main(int argc, char *argv[])
13      {
14              int i, j = 0;
(gdb) list
15
16              watch_variable_another();
17
18              for (i = 0; i < 5; i++)
19              {
20                      fprintf(stdout, "i :%d,", i);
21                      j++;
22                      fprintf(stdout, "j :%d\n", j);
23              }
24
(gdb) list
25              return 0;
26      }
(gdb) list
Line number 27 out of range; pool4watch.c has 26 lines.
(gdb) start 
Temporary breakpoint 1 at 0x400522: file pool4watch.c, line 14.
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Temporary breakpoint 1, main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:14
14              int i, j = 0;
(gdb) s
16              watch_variable_another();
(gdb) s
watch_variable_another () at pool4watch.c:6
6               for (k = 0; k < 5; k++)
(gdb) finish
Run till exit from #0  watch_variable_another () at pool4watch.c:6
k:0
k:1
k:2
k:3
k:4
main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:18
18              for (i = 0; i < 5; i++)
Value returned is $1 = 0
(gdb) finish
"finish" not meaningful in the outermost frame.
(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) n
Program not restarted.
(gdb) c
Continuing.
i :0,j :1
i :1,j :2
i :2,j :3
i :3,j :4
i :4,j :5

Program exited normally.

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
until 或 u
    当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。

(gdb) start 
Temporary breakpoint 2 at 0x400522: file pool4watch.c, line 14.
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Temporary breakpoint 2, main (argc=1, argv=0x7fffffffe9c8) at pool4watch.c:14
14              int i, j = 0;
(gdb) u
16              watch_variable_another();
(gdb) u
k:0
k:1
k:2
k:3
k:4
18              for (i = 0; i < 5; i++)
(gdb) u
20                      fprintf(stdout, "i :%d,", i);
(gdb) u
21                      j++;
(gdb) u
22                      fprintf(stdout, "j :%d\n", j);
(gdb) u
i :0,j :1
18              for (i = 0; i < 5; i++)
(gdb) u
i :1,j :2
i :2,j :3
i :3,j :4
i :4,j :5
25              return 0;
(gdb) 


＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

stepi 或 si
nexti 或 ni
    单步跟踪一条机器指令！一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令。与之一样有相同功能的命令是 “display/i $pc” ，当运行完这个命令后，单步跟踪会在打出程序代码的同时打出机器指令（也就是汇编代码） 

(gdb) start 
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Temporary breakpoint 5 at 0x400522: file pool4watch.c, line 14.
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Temporary breakpoint 5, main (argc=1, argv=0x7fffffffe9c8) at pool4watch.c:14
14              int i, j = 0;
(gdb) stepi
16              watch_variable_another();
(gdb) stepi
watch_variable_another () at pool4watch.c:4
4       {
(gdb) stepi
0x00000000004004d9      4       {
(gdb) stepi
0x00000000004004dc      4       {
(gdb) stepi
6               for (k = 0; k < 5; k++)
(gdb) stepi
0x00000000004004e7      6               for (k = 0; k < 5; k++)
(gdb) stepi
0x0000000000400506      6               for (k = 0; k < 5; k++)
(gdb) stepi
0x000000000040050a      6               for (k = 0; k < 5; k++)
(gdb) stepi
8                       fprintf(stdout, "k:%d\n", k);
(gdb) stepi
0x00000000004004f0      8                       fprintf(stdout, "k:%d\n", k);
(gdb) stepi
0x00000000004004f3      8                       fprintf(stdout, "k:%d\n", k);
(gdb) c
Continuing.
k:0
k:1
k:2
k:3
k:4
i :0,j :1
i :1,j :2
i :2,j :3
i :3,j :4
i :4,j :5

Program exited normally.
(gdb) 

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
