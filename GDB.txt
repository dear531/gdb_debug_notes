GDB设置命令行参数:
 一般有2种方法。
    1 直接跟在run后面
     (gdb) r arg1 arg2 ...
    2 用命令
     (gdb) set args arg1 arg2 ...
上述两步操作必须要在程序未运行起来之前，或是在程序运行起来之时进行赋值，如若会出现不生效的情况。

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

命令行参数的传入：
两种方法：
1。run ＋ 命令行
run -p 123
Starting program: /root/test/a.out -p 123
opt:123

Program exited normally.

2。set args ＋ 命令行
(gdb) set args -p 456
(gdb) run 
Starting program: /root/test/a.out -p 456
opt:456

Program exited normally.

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

查看程序的状态：
info grogram
(gdb) info program 
        Using the running image of child process 22717.
Program stopped at 0x4004e7.
It stopped at a breakpoint that has since been deleted.
(gdb) 

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
观察点设置：

(gdb) start 
Temporary breakpoint 1 at 0x4004e7: file pool4watch.c, line 7.
Starting program: /root/test/a.out 
i＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

Temporary breakpoint 1, main (argc=1, argv=0x7fffffffea58) at pool4watch.c:7
7               for (i = 0; i < 5; i++) 
(gdb) info program 
        Using the running image of child process 29284.
Program stopped at 0x4004e7.
It stopped at a breakpoint that has since been deleted.
(gdb) list
2
3       int main(int argc, char *argv[])
4       {
5               int i;
6               int j;
7               for (i = 0; i < 5; i++)
8               {
9                       fprintf(stdout, "i :%d", i);
10                      j++;
11                      fprintf(stdout, "j :%d\n", j);
(gdb) watch 10
Cannot watch constant value 10.
(gdb) break 10
Breakpoint 2 at 0x400509: file pool4watch.c, line 10.
(gdb) run 
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /root/test/a.out 

Breakpoint 2, main (argc=1, argv=0x7fffffffea58) at pool4watch.c:10
10                      j++;
(gdb) watch j
Hardware watchpoint 3: j
(gdb) c
Continuing.
i :0j :1

Breakpoint 2, main (argc=1, argv=0x7fffffffea58) at pool4watch.c:10
10                      j++;
(gdb) print j
$1 = 1
(gdb) c
Continuing.
i :1j :2

Breakpoint 2, main (argc=1, argv=0x7fffffffea58) at pool4watch.c:10
10                      j++;
(gdb) print j
$2 = 2
(gdb) 

＝＝＝＝＝＝＝＝＝＝＝
使用watch时步骤如下：

1. 使用break在要观察的变量所在处设置断电；

2. 使用run执行，直到断点；

3. 使用watch设置观察点；

4. 使用continue观察设置的观察点是否有变化。

注意，以上步骤前三步为一次性的设置，而第四步为成寻运行起来之后，在程序停在断点的时候让程序继续运行的设置。

＝＝＝＝＝＝＝＝＝＝＝
gdb 在断点打印,分别为设置断点号方法和不设置断点号方法：

1.设置断点号码的方法：

(gdb) break 9
Breakpoint 36 at 0x400510: file pool4watch.c, line 9.
(gdb) commands 36
Type commands for when breakpoint 36 is hit, one per line.
End with a line saying just "end".
>printf "i:%d\n",i
>continue
>end
(gdb) run
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Breakpoint 36, main (argc=1, argv=0x7fffffffe9c8) at pool4watch.c:9
9                       j++;
i:0
i :0,j :1

Breakpoint 36, main (argc=1, argv=0x7fffffffe9c8) at pool4watch.c:9
9                       j++;
i:1
i :1,j :2

Breakpoint 36, main (argc=1, argv=0x7fffffffe9c8) at pool4watch.c:9
9                       j++;
i:2
i :2,j :3

Breakpoint 36, main (argc=1, argv=0x7fffffffe9c8) at pool4watch.c:9
9                       j++;
i:3
i :3,j :4

Breakpoint 36, main (argc=1, argv=0x7fffffffe9c8) at pool4watch.c:9
9                       j++;
i:4
i :4,j :5

Program exited normally.
(gdb) 

2.不设置断点号的方法，新设置的commadn命令，会自动查找最近设置的断点号，并附加其上：
(gdb) break 9
Breakpoint 1 at 0x400510: file pool4watch.c, line 9.
(gdb) commands 
Type commands for when breakpoint 1 is hit, one per line.
End with a line saying just "end".
>printf "i :%d\n",i
>continue
>end
(gdb) run 
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Breakpoint 1, main (argc=1, argv=0x7fffffffe9c8) at pool4watch.c:9
9                       j++;
i :0
i :0,j :1

Breakpoint 1, main (argc=1, argv=0x7fffffffe9c8) at pool4watch.c:9
9                       j++;
i :1
i :1,j :2

Breakpoint 1, main (argc=1, argv=0x7fffffffe9c8) at pool4watch.c:9
9                       j++;
i :2
i :2,j :3

Breakpoint 1, main (argc=1, argv=0x7fffffffe9c8) at pool4watch.c:9
9                       j++;
i :3
i :3,j :4

Breakpoint 1, main (argc=1, argv=0x7fffffffe9c8) at pool4watch.c:9
9                       j++;
i :4
i :4,j :5

Program exited normally.
(gdb) 
(gdb) info breakpoints 
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000400510 in main at pool4watch.c:9
        breakpoint already hit 5 times
        printf "i :%d\n",i
        continue
(gdb) 

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

查看观察点方法：
watch <expr>
    为表达式（变量）expr设置一个观察点。一表达式值有变化时，马上停住程序。 

rwatch(read) <expr>
    当表达式（变量）expr被读时，停住程序。 

awatch(access:read/write) <expr>
    当表达式（变量）的值被读或被写时，停住程序。 

info watchpoints
    列出当前所设置了的所有观察点。 
(gdb) start 
Temporary breakpoint 1 at 0x4004e7: file pool4watch.c, line 5.
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Temporary breakpoint 1, main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:5
5               int i, j = 0;
(gdb) watch i
Hardware watchpoint 2: i
(gdb) awatch i
Hardware access (read/write) watchpoint 3: i
(gdb) rwatch i
Hardware read watchpoint 4: i
(gdb) info watchpoints 
Num     Type           Disp Enb Address            What
2       hw watchpoint  keep y                      i
3       acc watchpoint keep y                      i
4       read watchpoint keep y                      i
(gdb) c
Continuing.
Hardware access (read/write) watchpoint 3: i

Value = 0
Hardware read watchpoint 4: i

Value = 0
0x00000000004004f5 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:6
6               for (i = 0; i < 5; i++)
(gdb) c
Continuing.
Hardware access (read/write) watchpoint 3: i

Value = 0
Hardware read watchpoint 4: i

Value = 0
0x0000000000400535 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:6
6               for (i = 0; i < 5; i++)
(gdb) c
Continuing.
Hardware access (read/write) watchpoint 3: i

Value = 0
Hardware read watchpoint 4: i

Value = 0
0x0000000000400501 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:8
8                       fprintf(stdout, "i :%d,", i);
(gdb) c
Continuing.
i :0,j :1
Hardware watchpoint 2: i

Old value = 0
New value = 1
Hardware access (read/write) watchpoint 3: i

Old value = 0
New value = 1
0x0000000000400531 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:6
6               for (i = 0; i < 5; i++)
(gdb) c
Continuing.
Hardware access (read/write) watchpoint 3: i

Value = 1
Hardware read watchpoint 4: i

Value = 1
0x0000000000400535 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:6
6               for (i = 0; i < 5; i++)
(gdb) c
Continuing.
Hardware access (read/write) watchpoint 3: i

Value = 1
Hardware read watchpoint 4: i

Value = 1
0x0000000000400501 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:8
8                       fprintf(stdout, "i :%d,", i);
(gdb) c
Continuing.
i :1,j :2
Hardware watchpoint 2: i

Old value = 1
New value = 2
Hardware access (read/write) watchpoint 3: i

Old value = 1
New value = 2
0x0000000000400531 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:6
6               for (i = 0; i < 5; i++)
(gdb) c
Continuing.
Hardware access (read/write) watchpoint 3: i

Value = 2
Hardware read watchpoint 4: i

Value = 2
0x0000000000400535 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:6
6               for (i = 0; i < 5; i++)
(gdb) c
Continuing.
Hardware access (read/write) watchpoint 3: i

Value = 2
Hardware read watchpoint 4: i

Value = 2
0x0000000000400501 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:8
8                       fprintf(stdout, "i :%d,", i);
(gdb) c
Continuing.
i :2,j :3
Hardware watchpoint 2: i

Old value = 2
New value = 3
Hardware access (read/write) watchpoint 3: i

Old value = 2
New value = 3
0x0000000000400531 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:6
6               for (i = 0; i < 5; i++)
(gdb) c
Continuing.
Hardware access (read/write) watchpoint 3: i

Value = 3
Hardware read watchpoint 4: i

Value = 3
0x0000000000400535 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:6
6               for (i = 0; i < 5; i++)
(gdb) c
Continuing.
Hardware access (read/write) watchpoint 3: i

Value = 3
Hardware read watchpoint 4: i

Value = 3
0x0000000000400501 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:8
8                       fprintf(stdout, "i :%d,", i);
(gdb) c
Continuing.
i :3,j :4
Hardware watchpoint 2: i

Old value = 3
New value = 4
Hardware access (read/write) watchpoint 3: i

Old value = 3
New value = 4
0x0000000000400531 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:6
6               for (i = 0; i < 5; i++)
(gdb) c
Continuing.
Hardware access (read/write) watchpoint 3: i

Value = 4
Hardware read watchpoint 4: i

Value = 4
0x0000000000400535 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:6
6               for (i = 0; i < 5; i++)
(gdb) c
Continuing.
Hardware access (read/write) watchpoint 3: i

Value = 4
Hardware read watchpoint 4: i

Value = 4
0x0000000000400501 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:8
8                       fprintf(stdout, "i :%d,", i);
(gdb) c
Continuing.
i :4,j :5
Hardware watchpoint 2: i

Old value = 4
New value = 5
Hardware access (read/write) watchpoint 3: i

Old value = 4
New value = 5
0x0000000000400531 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:6
6               for (i = 0; i < 5; i++)
(gdb) c
Continuing.
Hardware access (read/write) watchpoint 3: i

Value = 5
Hardware read watchpoint 4: i

Value = 5
0x0000000000400535 in main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:6
6               for (i = 0; i < 5; i++)
(gdb) c
Continuing.

Watchpoint 2 deleted because the program has left the block in
which its expression is valid.

Watchpoint 3 deleted because the program has left the block in
which its expression is valid.

Watchpoint 4 deleted because the program has left the block in
which its expression is valid.
0x000000347861d994 in __libc_start_main () from /lib64/libc.so.6
(gdb) c
Continuing.

Program exited normally.
(gdb) info watchpoints 
No breakpoints or watchpoints.
(gdb) 

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

watch是有作用域的，只有在有效的作用域内，才能可以设置为该变量的观察点。
  1 #include <stdio.h>
  2 
  3 int watch_variable_another(void)
  4 {
  5         int k;
  6         for (k = 0; k < 5; k++)
  7         {
  8                 fprintf(stdout, "k:%d\n", k);
  9         }
 10         return 0;
 11 }
 12 int main(int argc, char *argv[])
 13 {
 14         int i, j = 0;
 15         for (i = 0; i < 5; i++)
 16         {
 17                 fprintf(stdout, "i :%d,", i);
 18                 j++;
 19                 fprintf(stdout, "j :%d\n", j);
 20         }
 21         watch_variable_another();
 22 
 23         return 0;
 24 }

以下是上述代码在调试的结果，只有在进入子函数当中，变量"k"的观察点才生效。

(gdb) start 
Temporary breakpoint 1 at 0x400522: file pool4watch.c, line 14.
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Temporary breakpoint 1, main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:14
14              int i, j = 0;
(gdb) watch k
No symbol "k" in current context.
(gdb) n
15              for (i = 0; i < 5; i++)
(gdb) n
17                      fprintf(stdout, "i :%d,", i);
(gdb) n
18                      j++;
(gdb) n
19                      fprintf(stdout, "j :%d\n", j);
(gdb) n
i :0,j :1
15              for (i = 0; i < 5; i++)
(gdb) n
17                      fprintf(stdout, "i :%d,", i);
(gdb) n
18                      j++;
(gdb) list
13      {
14              int i, j = 0;
15              for (i = 0; i < 5; i++)
16              {
17                      fprintf(stdout, "i :%d,", i);
18                      j++;
19                      fprintf(stdout, "j :%d\n", j);
20              }
21              watch_variable_another();
22
(gdb) break 20
Breakpoint 2 at 0x400572: file pool4watch.c, line 20.
(gdb) c
Continuing.
i :1,j :2
i :2,j :3
i :3,j :4
i :4,j :5

Breakpoint 2, main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:21
21              watch_variable_another();
(gdb) watch k
No symbol "k" in current context.
(gdb) s
watch_variable_another () at pool4watch.c:6
6               for (k = 0; k < 5; k++)
(gdb) watch k
Hardware watchpoint 3: k
(gdb) 

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

停止条件维护clean和delete删除维护点的区别：
clean删除行号，delete断点号。

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
前面在说到设置断点时，我们提到过可以设置一个条件，当条件成立时，程序自动停止，这是一个非常强大的功能，这里，我想专门说说这个条件的相关维护命令。一般来说，为断点设置一个条件，我们使用if关键词，后面跟其断点条件。并且，条件设置好后，我们可以用condition命令来修改断点的条件。（只有break和watch命令支持if，catch目前暂不支持if）

condition <bnum> <expression>
    修改断点号为bnum的停止条件为expression。 

condition <bnum>
    清除断点号为bnum的停止条件。 
停止点条件变更：condition

(gdb) break 18
Breakpoint 1 at 0x40054b: file pool4watch.c, line 18.
(gdb) info breakpoints 
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x000000000040054b in main at pool4watch.c:18
(gdb) condition 1 i>2
(gdb) info breakpoints 
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x000000000040054b in main at pool4watch.c:18
        stop only if i>2
(gdb) 

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
还有一个比较特殊的维护命令ignore，你可以指定程序运行时，忽略停止条件几次。

ignore <bnum> <count>
    表示忽略断点号为bnum的停止条件count次。 

忽略断点ignore
Reading symbols from /mnt/data/gdb_debug_notes/source_code/a.out...done.
(gdb) list
5               int k;
6               for (k = 0; k < 5; k++)
7               {
8                       fprintf(stdout, "k:%d\n", k);
9               }
10              return 0;
11      }
12      int main(int argc, char *argv[])
13      {
14              int i, j = 0;
(gdb) list
15              for (i = 0; i < 5; i++)
16              {
17                      fprintf(stdout, "i :%d,", i);
18                      j++;
19                      fprintf(stdout, "j :%d\n", j);
20              }
21              watch_variable_another();
22
23              return 0;
24      }
(gdb) break 18
Breakpoint 1 at 0x40054b: file pool4watch.c, line 18.
(gdb) ignore 1 2
Will ignore next 2 crossings of breakpoint 1.
(gdb) run
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 
i :0,j :1
i :1,j :2

Breakpoint 1, main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:18
18                      j++;
(gdb) c
Continuing.
i :2,j :3

Breakpoint 1, main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:18
18                      j++;
(gdb) c
Continuing.
i :3,j :4

Breakpoint 1, main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:18
18                      j++;
(gdb) c
Continuing.
i :4,j :5
k:0
k:1
k:2
k:3
k:4

Program exited normally.
(gdb) 


＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
为停止点设定运行命令

我们可以使用GDB提供的command命令来设置停止点的运行命令。也就是说，当运行的程序在被停止住时，我们可以让其自动运行一些别的命令，这很有利行自动化调试。对基于GDB的自动化调试是一个强大的支持。

commands [bnum]
... command-list ...
end

为断点号bnum指写一个命令列表。当程序被该断点停住时，gdb会依次运行命令列表中的命令。例如：

break foo if x>0
commands
printf "x is %d\n",x
continue
end

断点设置在函数foo中，断点条件是x>0，如果程序被断住后，也就是，一旦x的值在foo函数中大于0，GDB会自动打印出x的值，并继续运行程序。

如果你要清除断点上的命令序列，那么只要简单的执行一下commands命令，并直接再打个end就行了。 

example:
(gdb) list
5               int k;
6               for (k = 0; k < 5; k++)
7               {
8                       fprintf(stdout, "k:%d\n", k);
9               }
10              return 0;
11      }
12      int main(int argc, char *argv[])
13      {
14              int i, j = 0;
(gdb) list
15              for (i = 0; i < 5; i++)
16              {
17                      fprintf(stdout, "i :%d,", i);
18                      j++;
19                      fprintf(stdout, "j :%d\n", j);
20              }
21              watch_variable_another();
22
23              return 0;
24      }
(gdb) break 18 if i%2==0
Breakpoint 1 at 0x40054b: file pool4watch.c, line 18.
(gdb) commands
Type commands for when breakpoint 1 is hit, one per line.
End with a line saying just "end".
>printf "i*2 = %d\n",i*2
>continue
>end
(gdb) run
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Breakpoint 1, main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:18
18                      j++;
i*2 = 0
i :0,j :1
i :1,j :2

Breakpoint 1, main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:18
18                      j++;
i*2 = 4
i :2,j :3
i :3,j :4

Breakpoint 1, main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:18
18                      j++;
i*2 = 8
i :4,j :5
k:0
k:1
k:2
k:3
k:4

Program exited normally.
(gdb) 

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
step或next命令单步跟踪程序。

continue [ignore-count]
c [ignore-count]
fg [ignore-count]
    恢复程序运行，直到程序结束，或是下一个断点到来。ignore-count表示忽略其后的断点次数。continue，c，fg三个命令都是一样的意思。 

step <count>
    单步跟踪，如果有函数调用，他会进入该函数。进入函数的前提是，此函数被编译有debug信息。很像VC等工具中的step in。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。 

next <count>
    同样单步跟踪，如果有函数调用，他不会进入该函数。很像VC等工具中的step over。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。 

(gdb) list
1       #include <stdio.h>
2
3       int watch_variable_another(void)
4       {
5               int k;
6               for (k = 0; k < 5; k++)
7               {
8                       fprintf(stdout, "k:%d\n", k);
9               }
10              return 0;
(gdb) list
11      }
12      int main(int argc, char *argv[])
13      {
14              int i, j = 0;
15              for (i = 0; i < 5; i++)
16              {
17                      fprintf(stdout, "i :%d,", i);
18                      j++;
19                      fprintf(stdout, "j :%d\n", j);
20              }
(gdb) list
21              watch_variable_another();
22
23              return 0;
24      }
(gdb) list
Line number 25 out of range; pool4watch.c has 24 lines.
(gdb) start 
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Temporary breakpoint 6 at 0x400522: file pool4watch.c, line 14.
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Temporary breakpoint 6, main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:14
14              int i, j = 0;
(gdb) n 3
18                      j++;
(gdb) n 5
i :0,j :1
19                      fprintf(stdout, "j :%d\n", j);
(gdb) s 10
i :1,j :2
i :2,j :3
i :3,j :4
17                      fprintf(stdout, "i :%d,", i);
(gdb) s 1
18                      j++;
(gdb) s
19                      fprintf(stdout, "j :%d\n", j);
(gdb) s 2
i :4,j :5
21              watch_variable_another();
(gdb) s 10
k:0
k:1
k:2
k:3
8                       fprintf(stdout, "k:%d\n", k);
(gdb) s 2
k:4
10              return 0;
(gdb) s
11      }
(gdb) s
main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:23
23              return 0;
(gdb) 

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
set step-mode
set step-mode on
    打开step-mode模式，于是，在进行单步跟踪时，程序不会因为没有debug信息而不停住。这个参数很有利于查看机器码。 

set step-mode off
    关闭step-mode模式。 
如果代码没有调试信息，那么设置step模式开启，也是见很痛苦的事：
第一，c代码汇编为机器码之后要比c行数多的多。
第二，当代码涉及到系统库函数时，也会跟进去，这时候可以用finish结束。这个语句除了结束自定义函数，也可以用来结束库函数。

(gdb) set step-mode on
(gdb) start 
Temporary breakpoint 5 at 0x400517
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Temporary breakpoint 5, 0x0000000000400517 in main ()
(gdb) n
0x000000000040051b in main ()
(gdb) s
0x000000000040051e in main ()
(gdb) s
0x0000000000400522 in main ()
(gdb) s
0x0000000000400529 in main ()
(gdb) s
0x00000000004004d8 in watch_variable_another ()
(gdb) s
0x00000000004004d9 in watch_variable_another ()
(gdb) s
0x00000000004004dc in watch_variable_another ()
(gdb) s
0x00000000004004e0 in watch_variable_another ()
(gdb) s
0x00000000004004e7 in watch_variable_another ()
(gdb) s
0x0000000000400506 in watch_variable_another ()
(gdb) s
0x000000000040050a in watch_variable_another ()
(gdb) s
0x00000000004004e9 in watch_variable_another ()
(gdb) s
0x00000000004004f0 in watch_variable_another ()
(gdb) s
0x00000000004004f3 in watch_variable_another ()
(gdb) s
0x00000000004004f8 in watch_variable_another ()
(gdb) n
0x00000000004004fd in watch_variable_another ()
(gdb) finish
Run till exit from #0  0x00000000004004fd in watch_variable_another ()
k:0
k:1
k:2
k:3
k:4
0x000000000040052e in main ()
(gdb) s
0x0000000000400535 in main ()
(gdb) s
0x0000000000400571 in main ()
(gdb) s
0x0000000000400575 in main ()
(gdb) s
0x0000000000400537 in main ()
(gdb) s
0x000000000040053e in main ()
(gdb) print i
No symbol table is loaded.  Use the "file" command.
(gdb) s
0x0000000000400541 in main ()
(gdb) s
0x0000000000400546 in main ()
(gdb) s
0x000000000040054b in main ()
(gdb) s
0x000000347864d2d0 in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2d7 in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2dc in fprintf () from /lib64/libc.so.6
(gdb) finish
Run till exit from #0  0x000000347864d2dc in fprintf () from /lib64/libc.so.6
0x0000000000400550 in main ()
(gdb) s
0x0000000000400554 in main ()
(gdb) s
0x000000000040055b in main ()
(gdb) s
0x000000000040055e in main ()
(gdb) s
0x0000000000400563 in main ()
(gdb) s
0x0000000000400568 in main ()
(gdb) s
0x000000347864d2d0 in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2d7 in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2dc in fprintf () from /lib64/libc.so.6
(gdb) finish
Run till exit from #0  0x000000347864d2dc in fprintf () from /lib64/libc.so.6
i :0,j :1
0x000000000040056d in main ()
(gdb) s
0x0000000000400571 in main ()
(gdb) s
0x0000000000400575 in main ()
(gdb) s
0x0000000000400537 in main ()
(gdb) s
0x000000000040053e in main ()
(gdb) n
0x0000000000400541 in main ()
(gdb) n
0x0000000000400546 in main ()
(gdb) n
0x000000000040054b in main ()
(gdb) n
0x0000000000400550 in main ()
(gdb) n
0x0000000000400554 in main ()
(gdb) finish
"finish" not meaningful in the outermost frame.
(gdb) s
0x000000000040055b in main ()
(gdb) s
0x000000000040055e in main ()
(gdb) s
0x0000000000400563 in main ()
(gdb) s
0x0000000000400568 in main ()
(gdb) s
0x000000347864d2d0 in fprintf () from /lib64/libc.so.6
(gdb) finish
Run till exit from #0  0x000000347864d2d0 in fprintf () from /lib64/libc.so.6
i :1,j :2
0x000000000040056d in main ()
(gdb) s
0x0000000000400571 in main ()
(gdb) s
0x0000000000400575 in main ()
(gdb) s
0x0000000000400537 in main ()
(gdb) s
0x000000000040053e in main ()
(gdb) s
0x0000000000400541 in main ()
(gdb) s
0x0000000000400546 in main ()
(gdb) s
0x000000000040054b in main ()
(gdb) s
0x000000347864d2d0 in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2d7 in fprintf () from /lib64/libc.so.6
(gdb) finish
Run till exit from #0  0x000000347864d2d7 in fprintf () from /lib64/libc.so.6
0x0000000000400550 in main ()
(gdb) s
0x0000000000400554 in main ()
(gdb) s
0x000000000040055b in main ()
(gdb) s
0x000000000040055e in main ()
(gdb) s
0x0000000000400563 in main ()
(gdb) s
0x0000000000400568 in main ()
(gdb) s
0x000000347864d2d0 in fprintf () from /lib64/libc.so.6
(gdb) finish
Run till exit from #0  0x000000347864d2d0 in fprintf () from /lib64/libc.so.6
i :2,j :3
0x000000000040056d in main ()
(gdb) s
0x0000000000400571 in main ()
(gdb) s
0x0000000000400575 in main ()
(gdb) s
0x0000000000400537 in main ()
(gdb) s
0x000000000040053e in main ()
(gdb) s
0x0000000000400541 in main ()
(gdb) s
0x0000000000400546 in main ()
(gdb) s
0x000000000040054b in main ()
(gdb) s
0x000000347864d2d0 in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2d7 in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2dc in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2df in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2e4 in fprintf () from /lib64/libc.so.6
(gdb) finish
Run till exit from #0  0x000000347864d2e4 in fprintf () from /lib64/libc.so.6
0x0000000000400550 in main ()
(gdb) s
0x0000000000400554 in main ()
(gdb) s
0x000000000040055b in main ()
(gdb) s
0x000000000040055e in main ()
(gdb) s
0x0000000000400563 in main ()
(gdb) s
0x0000000000400568 in main ()
(gdb) s
0x000000347864d2d0 in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2d7 in fprintf () from /lib64/libc.so.6
(gdb) finish
Run till exit from #0  0x000000347864d2d7 in fprintf () from /lib64/libc.so.6
i :3,j :4
0x000000000040056d in main ()
(gdb) s
0x0000000000400571 in main ()
(gdb) s
0x0000000000400575 in main ()
(gdb) s
0x0000000000400537 in main ()
(gdb) s
0x000000000040053e in main ()
(gdb) s
0x0000000000400541 in main ()
(gdb) s
0x0000000000400546 in main ()
(gdb) s
0x000000000040054b in main ()
(gdb) s
0x000000347864d2d0 in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2d7 in fprintf () from /lib64/libc.so.6
(gdb) finish
Run till exit from #0  0x000000347864d2d7 in fprintf () from /lib64/libc.so.6
0x0000000000400550 in main ()
(gdb) s
0x0000000000400554 in main ()
(gdb) s
0x000000000040055b in main ()
(gdb) s
0x000000000040055e in main ()
(gdb) s
0x0000000000400563 in main ()
(gdb) s
0x0000000000400568 in main ()
(gdb) s
0x000000347864d2d0 in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2d7 in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2dc in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2df in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2e4 in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2ec in fprintf () from /lib64/libc.so.6
(gdb) s
0x000000347864d2f3 in fprintf () from /lib64/libc.so.6
(gdb) finish
Run till exit from #0  0x000000347864d2f3 in fprintf () from /lib64/libc.so.6
i :4,j :5
0x000000000040056d in main ()
(gdb) s
0x0000000000400571 in main ()
(gdb) s
0x0000000000400575 in main ()
(gdb) s
0x0000000000400577 in main ()
(gdb) s
0x000000000040057c in main ()
(gdb) s
0x000000000040057d in main ()
(gdb) s
0x000000347861d994 in __libc_start_main () from /lib64/libc.so.6
(gdb) s
0x000000347861d996 in __libc_start_main () from /lib64/libc.so.6
(gdb) s
0x00000034786332c0 in exit () from /lib64/libc.so.6
(gdb) s
0x00000034786332c2 in exit () from /lib64/libc.so.6
(gdb) finish
Run till exit from #0  0x00000034786332c2 in exit () from /lib64/libc.so.6

Program exited normally.
(gdb) s
The program is not being run.

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
结束子函数执行：finish

finish
    运行程序，直到当前函数完成返回。并打印函数返回时的堆栈地址和返回值及参数值等信息。 
(gdb) list
5               int k;
6               for (k = 0; k < 5; k++)
7               {
8                       fprintf(stdout, "k:%d\n", k);
9               }
10              return 0;
11      }
12      int main(int argc, char *argv[])
13      {
14              int i, j = 0;
(gdb) list
15
16              watch_variable_another();
17
18              for (i = 0; i < 5; i++)
19              {
20                      fprintf(stdout, "i :%d,", i);
21                      j++;
22                      fprintf(stdout, "j :%d\n", j);
23              }
24
(gdb) list
25              return 0;
26      }
(gdb) list
Line number 27 out of range; pool4watch.c has 26 lines.
(gdb) start 
Temporary breakpoint 1 at 0x400522: file pool4watch.c, line 14.
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Temporary breakpoint 1, main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:14
14              int i, j = 0;
(gdb) s
16              watch_variable_another();
(gdb) s
watch_variable_another () at pool4watch.c:6
6               for (k = 0; k < 5; k++)
(gdb) finish
Run till exit from #0  watch_variable_another () at pool4watch.c:6
k:0
k:1
k:2
k:3
k:4
main (argc=1, argv=0x7fffffffe9a8) at pool4watch.c:18
18              for (i = 0; i < 5; i++)
Value returned is $1 = 0
(gdb) finish
"finish" not meaningful in the outermost frame.
(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) n
Program not restarted.
(gdb) c
Continuing.
i :0,j :1
i :1,j :2
i :2,j :3
i :3,j :4
i :4,j :5

Program exited normally.

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
until 或 u
    当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。

(gdb) start 
Temporary breakpoint 2 at 0x400522: file pool4watch.c, line 14.
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Temporary breakpoint 2, main (argc=1, argv=0x7fffffffe9c8) at pool4watch.c:14
14              int i, j = 0;
(gdb) u
16              watch_variable_another();
(gdb) u
k:0
k:1
k:2
k:3
k:4
18              for (i = 0; i < 5; i++)
(gdb) u
20                      fprintf(stdout, "i :%d,", i);
(gdb) u
21                      j++;
(gdb) u
22                      fprintf(stdout, "j :%d\n", j);
(gdb) u
i :0,j :1
18              for (i = 0; i < 5; i++)
(gdb) u
i :1,j :2
i :2,j :3
i :3,j :4
i :4,j :5
25              return 0;
(gdb) 


＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

stepi 或 si
nexti 或 ni
    单步跟踪一条机器指令！一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令。与之一样有相同功能的命令是 “display/i $pc” ，当运行完这个命令后，单步跟踪会在打出程序代码的同时打出机器指令（也就是汇编代码） 

(gdb) start 
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Temporary breakpoint 5 at 0x400522: file pool4watch.c, line 14.
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Temporary breakpoint 5, main (argc=1, argv=0x7fffffffe9c8) at pool4watch.c:14
14              int i, j = 0;
(gdb) stepi
16              watch_variable_another();
(gdb) stepi
watch_variable_another () at pool4watch.c:4
4       {
(gdb) stepi
0x00000000004004d9      4       {
(gdb) stepi
0x00000000004004dc      4       {
(gdb) stepi
6               for (k = 0; k < 5; k++)
(gdb) stepi
0x00000000004004e7      6               for (k = 0; k < 5; k++)
(gdb) stepi
0x0000000000400506      6               for (k = 0; k < 5; k++)
(gdb) stepi
0x000000000040050a      6               for (k = 0; k < 5; k++)
(gdb) stepi
8                       fprintf(stdout, "k:%d\n", k);
(gdb) stepi
0x00000000004004f0      8                       fprintf(stdout, "k:%d\n", k);
(gdb) stepi
0x00000000004004f3      8                       fprintf(stdout, "k:%d\n", k);
(gdb) c
Continuing.
k:0
k:1
k:2
k:3
k:4
i :0,j :1
i :1,j :2
i :2,j :3
i :3,j :4
i :4,j :5

Program exited normally.
(gdb) 

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
信号（Signals）

信号是一种软中断，是一种处理异步事件的方法。一般来说，操作系统都支持许多信号。尤其是 UNIX，比较重要应用程序一般都会处理信号。UNIX定义了许多信号，比如SIGINT表示中断字符信号，也就是Ctrl+C的信号，SIGBUS表示硬件故障的信号；SIGCHLD表示子进程状态改变信号；SIGKILL表示终止程序运行的信号，等等。信号量编程是UNIX下非常重要的一种技术。

GDB有能力在你调试程序的时候处理任何一种信号，你可以告诉GDB需要处理哪一种信号。你可以要求GDB收到你所指定的信号时，马上停住正在运行的程序，以供你进行调试。你可以用GDB的handle命令来完成这一功能。

handle <signal> <keywords...>

在GDB中定义一个信号处理。信号<signal>可以以SIG开头或不以SIG开头，可以用定义一个要处理信号的范围（如：SIGIO- SIGKILL，表示处理从SIGIO信号到SIGKILL的信号，其中包括SIGIO，SIGIOT，SIGKILL三个信号），也可以使用关键字 all来标明要处理所有的信号。一旦被调试的程序接收到信号，运行程序马上会被GDB停住，以供调试。其<keywords>可以是以下几种关键字的一个或多个。

nostop
    当被调试的程序收到信号时，GDB不会停住程序的运行，但会打出消息告诉你收到这种信号。 
stop
    当被调试的程序收到信号时，GDB会停住你的程序。 
print
    当被调试的程序收到信号时，GDB会显示出一条信息。 
noprint
    当被调试的程序收到信号时，GDB不会告诉你收到信号的信息。 
pass
noignore
    当被调试的程序收到信号时，GDB不处理信号。这表示，GDB会把这个信号交给被调试程序处理。 
nopass
ignore
    当被调试的程序收到信号时，GDB不会让被调试程序来处理这个信号。 
info signals
info handle
    查看有哪些信号在被GDB检测中。 


Reading symbols from /mnt/data/gdb_debug_notes/source_code/a.out...done.
(gdb) list
8               int err = errno;
9               errno = err;
10              return;
11      }
12
13      int main(void)
14      {
15              int i;
16      #if 1
17              signal(SIGINT, sig_int);
(gdb) list
18      #endif
19              for (i = 0; ; i++)
20              {
21                      sleep(1);
22                      fprintf(stdout, "i :%d\n", i);
23              }
24
25              return 0;
26      }
(gdb) info handle 
Signal        Stop      Print   Pass to program Description

SIGHUP        Yes       Yes     Yes             Hangup
SIGINT        Yes       Yes     No              Interrupt
SIGQUIT       Yes       Yes     Yes             Quit
SIGILL        Yes       Yes     Yes             Illegal instruction
SIGTRAP       Yes       Yes     No              Trace/breakpoint trap
.....

Use the "handle" command to change these tables.
(gdb) run
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 
i :0
i :1

Program received signal SIGINT, Interrupt.
0x000000347869a170 in __nanosleep_nocancel () from /lib64/libc.so.6
(gdb) c
Continuing.
i :2
i :3

Program received signal SIGINT, Interrupt.
0x000000347869a170 in __nanosleep_nocancel () from /lib64/libc.so.6
(gdb) handle SIGINT noprint nopass nostop
SIGINT is used by the debugger.
Are you sure you want to change it? (y or n) y
Signal        Stop      Print   Pass to program Description
SIGINT        No        No      No              Interrupt
(gdb) 
(gdb) c
Continuing.
i :4
i :5
i :6
i :7
i :8
i :9
i :10
/* 此时我们只能如输入其他信号，将程序打断，并且如果程序当中没有实现该信号的处理函数，被调式的程序会正常处理信号 */
Program received signal SIGQUIT, Quit.
0x000000347869a170 in __nanosleep_nocancel () from /lib64/libc.so.6
(gdb) c
Continuing.

Program terminated with signal SIGQUIT, Quit.
The program no longer exists.

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
查看栈信息

当程序被停住了，你需要做的第一件事就是查看程序是在哪里停住的。当你的程序调用了一个函数，函数的地址，函数参数，函数内的局部变量都会被压入“栈”（Stack）中。你可以用GDB命令来查看当前的栈中的信息。

下面是一些查看函数调用栈信息的GDB命令：

backtrace
bt
    打印当前的函数调用栈的所有信息。如： 

(gdb) bt
#0  func (n=250) at tst.c:6
#1  0x08048524 in main (argc=1, argv=0xbffff674) at tst.c:30
#2  0x400409ed in __libc_start_main () from /lib/libc.so.6
      

从上可以看出函数的调用栈信息：__libc_start_main --> main() --> func() 

example:
Reading symbols from /mnt/data/gdb_debug_notes/source_code/a.out...done.
(gdb) list
5               int k;
6               for (k = 0; k < 5; k++)
7               {
8                       fprintf(stdout, "k:%d\n", k);
9               }
10              return 0;
11      }
12      int main(int argc, char *argv[])
13      {
14              int i, j = 0;
(gdb) list
15
16              watch_variable_another();
17
18              for (i = 0; i < 5; i++)
19              {
20                      fprintf(stdout, "i :%d,", i);
21                      j++;
22                      fprintf(stdout, "j :%d\n", j);
23              }
24
(gdb) list
25              return 0;
26      }
(gdb) list
Line number 27 out of range; pool4watch.c has 26 lines.
(gdb) start 
Temporary breakpoint 1 at 0x400522: file pool4watch.c, line 14.
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Temporary breakpoint 1, main (argc=1, argv=0x7fffffffe708) at pool4watch.c:14
14              int i, j = 0;
(gdb) s
16              watch_variable_another();
(gdb) s
watch_variable_another () at pool4watch.c:6
6               for (k = 0; k < 5; k++)
(gdb) backtrace 
#0  watch_variable_another () at pool4watch.c:6
#1  0x000000000040052e in main (argc=1, argv=0x7fffffffe708) at pool4watch.c:16
(gdb) 

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
查看栈信息

当程序被停住了，你需要做的第一件事就是查看程序是在哪里停住的。当你的程序调用了一个函数，函数的地址，函数参数，函数内的局部变量都会被压入“栈”（Stack）中。你可以用GDB命令来查看当前的栈中的信息。

下面是一些查看函数调用栈信息的GDB命令：

backtrace
bt
    打印当前的函数调用栈的所有信息。如： 

(gdb) bt
#0  func (n=250) at tst.c:6
#1  0x08048524 in main (argc=1, argv=0xbffff674) at tst.c:30
#2  0x400409ed in __libc_start_main () from /lib/libc.so.6
      

从上可以看出函数的调用栈信息：__libc_start_main --> main() --> func()


backtrace <n>
bt <n>
    n是一个正整数，表示只打印栈顶上n层的栈信息。 

backtrace <-n>
bt <-n>
    -n表一个负整数，表示只打印栈底下n层的栈信息。 

如果你要查看某一层的信息，你需要切换当前栈，一般来说，程序停止时，最顶层的栈就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是切换当前栈。

frame <n>
f <n>
    n是一个从0开始的整数，是栈中的层编号。比如：frame 0，表示栈顶，frame 1，表示栈的第二层。 

up <n>
    表示向栈的上面移动n层，可以不打n，表示向上移动一层。 

down <n>
    表示向栈的下面移动n层，可以不打n，表示向下移动一层。 


上面的命令，都会打印出移动到的栈层的信息。如果你不想让其打出信息。你可以使用这三个命令：

select-frame <n> 对应于 frame 命令。
up-silently <n> 对应于 up 命令。
down-silently <n> 对应于 down 命令。

查看当前栈层的信息，你可以用以下GDB命令：

frame 或 f
    会打印出这些信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。 

info frame
info f
    这个命令会打印出更为详细的当前栈层的信息，只不过，大多数都是运行时的内存地址。比如：函数地址，调用函数的地址，被调用函数的地址，目前的函数是由什么样的程序语言写成的、函数参数地址及值、局部变量的地址等等。如： 

(gdb) info f
Stack level 0, frame at 0xbffff5d4:
eip = 0x804845d in func (tst.c:6); saved eip 0x8048524
called by frame at 0xbffff60c
source language c.
Arglist at 0xbffff5d4, args: n=250
Locals at 0xbffff5d4, Previous frame's sp is 0x0
Saved registers:
ebp at 0xbffff5d4, eip at 0xbffff5d8
            

info args
    打印出当前函数的参数名及其值。 

info locals
    打印出当前函数中所有局部变量及其值。 

info catch
    打印出当前的函数中的异常处理信息。 

example:
以下我们将综合演示以上命令，并结合过程展示每个命令在都是如何运用以及程序代码堆栈之间的关系。
Reading symbols from /mnt/data/gdb_debug_notes/source_code/a.out...done.
(gdb) list
5               int k;
6               for (k = 0; k < 5; k++)
7               {
8                       fprintf(stdout, "k:%d\n", k);
9               }
10              return 0;
11      }
12      int main(int argc, char *argv[])
13      {
14              int i, j = 0;
(gdb) list
15
16              watch_variable_another();
17
18              for (i = 0; i < 5; i++)
19              {
20                      fprintf(stdout, "i :%d,", i);
21                      j++;
22                      fprintf(stdout, "j :%d\n", j);
23              }
24
(gdb) list
25              return 0;
26      }
(gdb) start 
Temporary breakpoint 1 at 0x400522: file pool4watch.c, line 14.
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Temporary breakpoint 1, main (argc=1, argv=0x7fffffffe708) at pool4watch.c:14
14              int i, j = 0;
(gdb) s
16              watch_variable_another();
(gdb) s
watch_variable_another () at pool4watch.c:6
6               for (k = 0; k < 5; k++)
(gdb) s
8                       fprintf(stdout, "k:%d\n", k);
(gdb) backtrace 
#0  watch_variable_another () at pool4watch.c:8
#1  0x000000000040052e in main (argc=1, argv=0x7fffffffe708) at pool4watch.c:16
/* 以上为程序代码堆栈，0为watch_variable_anothe，1为main函数 */
(gdb) info locals /* 查看本层堆栈变量值 */
k = 0
(gdb) up /* 本层为0,移动到调用他的函数，及上一层 */
#1  0x000000000040052e in main (argc=1, argv=0x7fffffffe708) at pool4watch.c:16
16              watch_variable_another();
(gdb) info locals /* 查看上一层的堆栈变量列表 */
i = 0
j = 0
(gdb) info args /* 查看移动到的上一层，即当前本层的堆栈变量信息 */
argc = 1
argv = 0x7fffffffe708
(gdb) backtrace  /* 查看堆栈位置 */
#0  watch_variable_another () at pool4watch.c:8
#1  0x000000000040052e in main (argc=1, argv=0x7fffffffe708) at pool4watch.c:16
(gdb) down /* 返回当前层 */
#0  watch_variable_another () at pool4watch.c:8
8                       fprintf(stdout, "k:%d\n", k);


frame显示当前运行到的代码信息：

(gdb) frame 
#0  main (argc=1, argv=0x7fffffffe708) at array.c:9
9                       fprintf(stdout, "a[%d]:%d\n", i, a[i]);
(gdb) info frame 
Stack level 0, frame at 0x7fffffffe630:
 rip = 0x400518 in main (array.c:9); saved rip 0x347861d994
 source language c.
 Arglist at 0x7fffffffe620, args: argc=1, argv=0x7fffffffe708
 Locals at 0x7fffffffe620, Previous frame's sp is 0x7fffffffe630
 Saved registers:
  rbp at 0x7fffffffe620, rip at 0x7fffffffe628


＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
显示源代码

GDB 可以打印出所调试程序的源代码，当然，在程序编译时一定要加上-g的参数，把源程序信息编译到执行文件中。不然就看不到源程序了。当程序停下来以后，GDB会报告程序停在了那个文件的第几行上。你可以用list命令来打印程序的源代码。还是来看一看查看源代码的GDB命令吧。

list <linenum>
    显示程序第linenum行的周围的源程序。 
list <function>
    显示函数名为function的函数的源程序。 
list
    显示当前行后面的源程序。 
list -
    显示当前行前面的源程序。 

一般是打印当前行的上5行和下5行，如果显示函数是是上2行下8行，默认是10行，当然，你也可以定制显示的范围，使用下面命令可以设置一次显示源程序的行数。

set listsize <count>
    设置一次显示源代码的行数。 
show listsize
    查看当前listsize的设置。 

list命令还有下面的用法：

list <first>, <last>
    显示从first行到last行之间的源代码。 

list , <last>
    显示从当前行到last行之间的源代码。 

list +
    往后显示源代码。 

一般来说在list后面可以跟以下这些参数：

<linenum>   行号。
<+offset>   当前行号的正偏移量。
<-offset>   当前行号的负偏移量。
<filename:linenum>  哪个文件的哪一行。
<function>  函数名。
<filename:function> 哪个文件中的哪个函数。
<*address>  程序运行时的语句在内存中的地址

(gdb) list 3,12
3       int watch_variable_another(void)
4       {
5               int k;
6               for (k = 0; k < 5; k++)
7               {
8                       fprintf(stdout, "k:%d\n", k);
9               }
10              return 0;
11      }
12      int main(int argc, char *argv[])
(gdb) 

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
搜索源代码

不仅如此，GDB还提供了源代码搜索的命令：

forward-search <regexp>
search <regexp>
    向前面搜索。 
reverse-search <regexp>
    全部搜索。 

其中，<regexp>就是正则表达式，也主一个字符串的匹配模式，关于正则表达式，我就不在这里讲了，还请各位查看相关资料。 
(gdb) list
1       #include <stdio.h>
2
3       int watch_variable_another(void)
4       {
5               int k;
6               for (k = 0; k < 5; k++)
7               {
8                       fprintf(stdout, "k:%d\n", k);
9               }
10              return 0;
(gdb) list
11      }
12      int main(int argc, char *argv[])
13      {
14              int i, j = 0;
15
16              watch_variable_another();
17
18              for (i = 0; i < 5; i++)
19              {
20                      fprintf(stdout, "i :%d,", i);
(gdb) list
21                      j++;
22                      fprintf(stdout, "j :%d\n", j);
23              }
24
25              return 0;
26      }
(gdb) start 
Temporary breakpoint 1 at 0x400522: file pool4watch.c, line 14.
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Temporary breakpoint 1, main (argc=1, argv=0x7fffffffe708) at pool4watch.c:14
14              int i, j = 0;
(gdb) n
16              watch_variable_another();
(gdb) s
watch_variable_another () at pool4watch.c:6
6               for (k = 0; k < 5; k++)
(gdb) n
8                       fprintf(stdout, "k:%d\n", k);
(gdb) s
k:0
6               for (k = 0; k < 5; k++)
(gdb) s
8                       fprintf(stdout, "k:%d\n", k);
(gdb) until 
k:1
6               for (k = 0; k < 5; k++)
(gdb) u
k:2
k:3
k:4
10              return 0;
(gdb) search printf
20                      fprintf(stdout, "i :%d,", i);
(gdb) search printf
22                      fprintf(stdout, "j :%d\n", j);
(gdb) reverse-search printf
20                      fprintf(stdout, "i :%d,", i);
(gdb) reverse-search printf
8                       fprintf(stdout, "k:%d\n", k);
(gdb) reverse-search printf
Expression not found
总结，搜索的是从当前的位置开始的，向前和向后的位置都是相对当前位置。
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
指定源文件的路径

某些时候，用-g编译过后的执行程序中只是包括了源文件的名字，没有路径名。GDB提供了可以让你指定源文件的路径的命令，以便GDB进行搜索。

directory <dirname ... >
dir <dirname ... >
    加一个源文件路径到当前路径的前面。如果你要指定多个路径，UNIX下你可以使用“:”，Windows下你可以使用“;”。 
directory
    清除所有的自定义的源文件搜索路径信息。 
show directories
    显示定义了的源文件搜索路径。 

[编辑] 源代码的内存

你可以使用info line命令来查看源代码在内存中的地址。info line后面可以跟“行号”，“函数名”，“文件名:行号”，“文件名:函数名”，这个命令会打印出所指定的源码在运行时的内存地址，如：

(gdb) info line tst.c:func
Line 5 of "tst.c" starts at address 0x8048456 <func+6> and ends at 0x804845d <func+13>.

还有一个命令（disassemble）你可以查看源程序的当前执行时的机器码，这个命令会把目前内存中的指令dump出来。如下面的示例表示查看函数func的汇编代码。

(gdb) disassemble func
Dump of assembler code for function func:
0x8048450 <func>:       push   %ebp
0x8048451 <func+1>:     mov    %esp,%ebp
0x8048453 <func+3>:     sub    $0x18,%esp
0x8048456 <func+6>:     movl   $0x0,0xfffffffc(%ebp)
0x804845d <func+13>:    movl   $0x1,0xfffffff8(%ebp)
0x8048464 <func+20>:    mov    0xfffffff8(%ebp),%eax
0x8048467 <func+23>:    cmp    0x8(%ebp),%eax
0x804846a <func+26>:    jle    0x8048470 <func+32>
0x804846c <func+28>:    jmp    0x8048480 <func+48>
0x804846e <func+30>:    mov    %esi,%esi
0x8048470 <func+32>:    mov    0xfffffff8(%ebp),%eax
0x8048473 <func+35>:    add    %eax,0xfffffffc(%ebp)
0x8048476 <func+38>:    incl   0xfffffff8(%ebp)
0x8048479 <func+41>:    jmp    0x8048464 <func+20>
0x804847b <func+43>:    nop
0x804847c <func+44>:    lea    0x0(%esi,1),%esi
0x8048480 <func+48>:    mov    0xfffffffc(%ebp),%edx
0x8048483 <func+51>:    mov    %edx,%eax
0x8048485 <func+53>:    jmp    0x8048487 <func+55>
0x8048487 <func+55>:    mov    %ebp,%esp
0x8048489 <func+57>:    pop    %ebp
0x804848a <func+58>:    ret
End of assembler dump.
(gdb) disassemble
Dump of assembler code for function watch_variable_another:
0x00000000004004d8 <watch_variable_another+0>:  push   %rbp
0x00000000004004d9 <watch_variable_another+1>:  mov    %rsp,%rbp
0x00000000004004dc <watch_variable_another+4>:  sub    $0x10,%rsp
0x00000000004004e0 <watch_variable_another+8>:  movl   $0x0,-0x4(%rbp)
0x00000000004004e7 <watch_variable_another+15>: jmp    0x400506 <watch_variable_another+46>
0x00000000004004e9 <watch_variable_another+17>: mov    0x200470(%rip),%rdi        # 0x600960 <stdout@@GLIBC_2.2.5>
0x00000000004004f0 <watch_variable_another+24>: mov    -0x4(%rbp),%edx
0x00000000004004f3 <watch_variable_another+27>: mov    $0x400678,%esi
0x00000000004004f8 <watch_variable_another+32>: mov    $0x0,%eax
0x00000000004004fd <watch_variable_another+37>: callq  0x4003f0 <fprintf@plt>
0x0000000000400502 <watch_variable_another+42>: addl   $0x1,-0x4(%rbp)
0x0000000000400506 <watch_variable_another+46>: cmpl   $0x4,-0x4(%rbp)
0x000000000040050a <watch_variable_another+50>: jle    0x4004e9 <watch_variable_another+17>
0x000000000040050c <watch_variable_another+52>: mov    $0x0,%eax
0x0000000000400511 <watch_variable_another+57>: leaveq 
0x0000000000400512 <watch_variable_another+58>: retq   
End of assembler dump.

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
查看运行时数据

在你调试程序时，当程序被停住时，你可以使用print命令（简写命令为p），或是同义命令inspect来查看当前程序的运行数据。print命令的格式是：

print <expr>
print /<f> <expr>

<expr>是表达式，是你所调试的程序的语言的表达式（GDB可以调试多种编程语言），<f>是输出的格式，比如，如果要把表达式按16进制的格式输出，那么就是/x。 

(gdb) n
8                       fprintf(stdout, "k:%d\n", k);
(gdb) print /x k
$1 = 0x0
(gdb) s
k:0
6               for (k = 0; k < 5; k++)
(gdb) s
8                       fprintf(stdout, "k:%d\n", k);
(gdb) s
k:1
6               for (k = 0; k < 5; k++)
(gdb) s
8                       fprintf(stdout, "k:%d\n", k);
(gdb) print /x k
$2 = 0x2

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
数组

有时候，你需要查看一段连续的内存空间的值。比如数组的一段，或是动态分配的数据的大小。你可以使用GDB的“@”操作符，“@”的左边是第一个内存的地址的值，“@”的右边则是你想查看内存的长度。例如，你的程序中有这样的语句：

int *array = (int *) malloc (len * sizeof (int));
      

于是，在GDB调试过程中，你可以以如下命令显示出这个动态数组的取值：

p *array@len

@的左边是数组的首地址的值，也就是变量array所指向的内容，右边则是数据的长度，其保存在变量len中，其输出结果，大约是下面这个样子的：

(gdb) p *array@len
$1 = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40}

如果是静态数组的话，可以直接用print数组名，就可以显示数组中所有数据的内容了。 

example:

(gdb) list
1       #include <stdio.h>
2
3       int
4       main (int argc, char *argv[])
5       {
6               int a[10] = {0};
7               int i;
8               for (i = 0; i < sizeof (a) / sizeof (*a); i++)
9                       fprintf(stdout, "a[%d]:%d\n", i, a[i]);
10              for (i = 0; i < sizeof (a) / sizeof (*a); i++)
(gdb) list
11                      a[i] = i;
12              for (i = 0; i < sizeof (a) / sizeof (*a); i++)
13                      fprintf(stdout, "a[%d]:%d\n", i, a[i]);
14
15              return 0;
16      }
(gdb) start 
Temporary breakpoint 1 at 0x4004e7: file array.c, line 6.
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Temporary breakpoint 1, main (argc=1, argv=0x7fffffffe708) at array.c:6
6               int a[10] = {0};
(gdb) print *a@10
$1 = {0, 0, 2004990912, 52, 4195776, 0, 0, 0, -6400, 32767}
(gdb) s
8               for (i = 0; i < sizeof (a) / sizeof (*a); i++)
(gdb) u
9                       fprintf(stdout, "a[%d]:%d\n", i, a[i]);
(gdb) u
a[0]:0
8               for (i = 0; i < sizeof (a) / sizeof (*a); i++)
(gdb) u
a[1]:0
a[2]:0
a[3]:0
a[4]:0
a[5]:0
a[6]:0
a[7]:0
a[8]:0
a[9]:0
10              for (i = 0; i < sizeof (a) / sizeof (*a); i++)
(gdb) print *a@10
$2 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
从以上运行结果当中不难看出，程序运行时，虽然对局部变量进行了初始化，但在未使用前，内存当中的数仍然是未被清理过的，直到访问的时候才出现了打印值为0的情况。
(gdb) n
11                      a[i] = i;
(gdb) s
10              for (i = 0; i < sizeof (a) / sizeof (*a); i++)
(gdb) s
11                      a[i] = i;
(gdb) u
10              for (i = 0; i < sizeof (a) / sizeof (*a); i++)
(gdb) u
12              for (i = 0; i < sizeof (a) / sizeof (*a); i++)
(gdb) u
13                      fprintf(stdout, "a[%d]:%d\n", i, a[i]);
(gdb) u
a[0]:0
12              for (i = 0; i < sizeof (a) / sizeof (*a); i++)
(gdb) u
a[1]:1
a[2]:2
a[3]:3
a[4]:4
a[5]:5
a[6]:6
a[7]:7
a[8]:8
a[9]:9
15              return 0;
(gdb) print *a@10
$4 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
(gdb) n
16      }
(gdb) n
0x000000347861d994 in __libc_start_main () from /lib64/libc.so.6
(gdb) n
Single stepping until exit from function __libc_start_main, 
which has no line number information.

Program exited normally.
再有一点，程序结束并不是进行到return就结束的，而是return之后程序依旧作了很多工作，如上。

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
输出格式

一般来说，GDB会根据变量的类型输出变量的值。但你也可以自定义GDB的输出的格式。例如，你想输出一个整数的十六进制，或是二进制来查看这个整型变量的中的位的情况。要做到这样，你可以使用GDB的数据显示格式：

x  按十六进制格式显示变量。
d  按十进制格式显示变量。
u  按十六进制格式显示无符号整型。
o  按八进制格式显示变量。
t  按二进制格式显示变量。
a  按十六进制格式显示变量。
c  按字符格式显示变量。
f  按浮点数格式显示变量。

(gdb) p i
$21 = 101   
(gdb) p/a i
$22 = 0x65
(gdb) p/c i
$23 = 101 'e'
(gdb) p/f i
$24 = 1.41531145e-43
(gdb) p/x i
$25 = 0x65
(gdb) p/t i
$26 = 1100101

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
查看内存

你可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：

x/<n/f/u> <addr>
  

n、f、u是可选的参数。

    n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。
    f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地址是指令地址，那么格式可以是i。
    u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当我们指定了字节长度后，GDB会从指定的内存地址开始，读写指定字节，并把其当作一个值取出来。 

<addr>表示一个内存地址。

n/f/u三个参数可以一起使用。例如：

命令：x/3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十进制显示。 
The program is not being run.
(gdb) start 
Temporary breakpoint 2 at 0x4004e7: file array.c, line 6.
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Temporary breakpoint 2, main (argc=1, argv=0x7fffffffe708) at array.c:6
6               int a[10] = {0};
(gdb) backtrace 
#0  main (argc=1, argv=0x7fffffffe708) at array.c:6
(gdb) s
8               for (i = 0; i < sizeof (a) / sizeof (*a); i++)
(gdb) backtrace 
#0  main (argc=1, argv=0x7fffffffe708) at array.c:8
(gdb) info locals 
a = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
i = 0
(gdb) x/10dw &a
0x7fffffffe5f0: 0       0       0       0
0x7fffffffe600: 0       0       0       0
0x7fffffffe610: 0       0
(gdb) p &a
$5 = (int (*)[10]) 0x7fffffffe5f0
(gdb) p a
$6 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
(gdb) 


＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
自动显示

你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display。

display <expr>
display/<fmt> <expr>
display/<fmt> <addr>

expr是一个表达式，fmt表示显示的格式，addr表示内存地址，当你用display设定好了一个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。

格式i和s同样被display支持，一个非常有用的命令是：

display/i $pc

$pc是GDB的环境变量，表示着指令的地址，/i则表示输出格式为机器指令码，也就是汇编。于是当程序停下后，就会出现源代码和机器指令码相对应的情形，这是一个很有意思的功能。 

Reading symbols from /mnt/data/gdb_debug_notes/source_code/a.out...done.
(gdb) start 
Temporary breakpoint 1 at 0x4004e7: file array.c, line 6.
Starting program: /mnt/data/gdb_debug_notes/source_code/a.out 

Temporary breakpoint 1, main (argc=1, argv=0x7fffffffe708) at array.c:6
6               int a[10] = {0};
(gdb) display/i $pc
1: x/i $pc
0x4004e7 <main+15>:     movq   $0x0,-0x30(%rbp)
(gdb) display a
2: a = {0, 0, 2004990912, 52, 4195776, 0, 0, 0, -6400, 32767}
(gdb) s
8               for (i = 0; i < sizeof (a) / sizeof (*a); i++)
2: a = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
1: x/i $pc
0x40050f <main+55>:     movl   $0x0,-0x4(%rbp)
(gdb) n
9                       fprintf(stdout, "a[%d]:%d\n", i, a[i]);
2: a = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
1: x/i $pc
0x400518 <main+64>:     mov    -0x4(%rbp),%eax
(gdb) n
a[0]:0
8               for (i = 0; i < sizeof (a) / sizeof (*a); i++)
2: a = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
1: x/i $pc
0x40053a <main+98>:     addl   $0x1,-0x4(%rbp)
(gdb) delete display 1
(gdb) info display 
Auto-display expressions now in effect:
Num Enb Expression
2:   y  a
(gdb) 
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
